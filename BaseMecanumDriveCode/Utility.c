#pragma config(Sensor, dgtl1,  LeftBackEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  LeftFrontEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  ,               sensorTouch)
#pragma config(Sensor, dgtl6,  ,               sensorTouch)
#pragma config(Sensor, dgtl7,  ,               sensorTouch)
#pragma config(Sensor, dgtl8,  ,               sensorTouch)
#pragma config(Sensor, dgtl9,  RightFrontEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, RightBackEncoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           LeftBackTop,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port2,           LeftBackBottom, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           LeftFront,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           ExtraOne,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           ExtraTwo,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           RightFront,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           RightBackBottom, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          RightBackTop,  tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Math.c";

#define NEWARRAY
#ifdef NEWARRAY
int curved_value_array2[128] =
{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,31,32,32,33,33,34,34,35,35,36,36,37,37,38,38,39,39,
40,40,41,41,42,42,43,43,44,44,45,45,46,46,47,47,48,48,49,49,50,50,51,51,52,52,53,53,54,54,55,55,56,56,57,57,58,58,59,59,60,60,61,61,62,62,
63,63,64,64,65,65,66,66,67,67,68,68,69,69,70,73,77,80,84,88,91,95,98,102,106,109,113,116,120,124,127,127, 127};
const int VEXRT_DIVISOR2 = 1;
#endif

#define RF 0
#define RB 1
#define LF 2
#define LB 3
#define EX1 4
#define EX2 5


int v( int iActualValue )
{
	// Divide the VexRT value by VEXRT_DIVISOR to be able to look up the
	// array. Note: INT / INT discards the remainder and returns an INT.
	iActualValue = iActualValue / VEXRT_DIVISOR2;

	// Check if the argument passed in is negative or positive
	if ( iActualValue < 0 )
	{
		// Negative number, get its absolute value
		////iActualValue = abs( iActualValue );
	  // Look up the curved value in the array and return negative value
		return ( 0 - curved_value_array2[abs(iActualValue)] );
	}
	else
	{
	  // Look up the curved value in the array and return positive value
	  return curved_value_array2[iActualValue];
	}
}

void ResetEncoders()
{
  SensorValue[LeftBackEncoder] = 0;
  SensorValue[RightBackEncoder] = 0;
  SensorValue[LeftFrontEncoder] = 0;
  SensorValue[RightFrontEncoder] = 0;
}

int Encoder(int sensor)
{
  if (sensor == LB)
    return SensorValue[LeftBackEncoder];
  if (sensor == RB)
    return SensorValue[RightBackEncoder];
  if (sensor == LF)
    return SensorValue[LeftFrontEncoder];
  if (sensor == RF)
    return SensorValue[RightFrontEncoder];
  else
    return 0;

}


void move(int motorint, int power)
{
  if( motorint == RB)
    motor[RightBackTop] = motor[RightBackBottom] = power;
  else if ( motorint == RF )
    motor[RightFront] = power;
  else if ( motorint == LB )
    motor[LeftBackBottom] = motor[LeftBackTop] = power;
  else if ( motorint == LF )
    motor[LeftFront] = power;
  else if ( motorint == EX1 )
    motor[ExtraOne] = power;
  else if (motorint == EX2 )
    motor[ExtraTwo] = power;
}

void SimpleMecanumDrive()
{
   move(LF, v(vexRT(Ch3)) + v(vexRT(Ch4)) + v(vexRT(Ch1)));
   move(RB, v(vexRT(Ch3)) + v(vexRT(Ch4)) - v(vexRT(Ch1)));
   move(LB, v(vexRT(Ch3)) - v(vexRT(Ch4)) + v(vexRT(Ch1)));
   move(RF, v(vexRT(Ch3)) - v(vexRT(Ch4)) - v(vexRT(Ch1)));

}

void MecanumDrive()
{
  //Calculating the SWITCH
  int switchValue = 1;

  if(abs(vexRT(Ch1)) <= 25)
  {
    switchValue = 1;
  }
  else if (vexRT(Ch3) * vexRT(Ch3) + vexRT(Ch4) * vexRT(Ch4) <= 625)
  {
    switchValue = 2;
  }
  else if ( abs(vexRT(Ch3)) >= 70 && abs(vexRT(Ch4)) <= 20 )
  {
    switchValue = 3;
  }


  //There are three different options

  switch(switchValue)
  {
    case 1: //Pure Mecanum Drive
      move(LF, v(vexRT(Ch3)) + v(vexRT(Ch4)));
      move(RB, v(vexRT(Ch3)) + v(vexRT(Ch4)));
      move(LB, v(vexRT(Ch3)) - v(vexRT(Ch4)));
      move(RF, v(vexRT(Ch3)) - v(vexRT(Ch4)));
    case 2: //Spinning
      move(LF, vexRT(Ch1));
      move(LB, vexRT(Ch1));
      move(RF, -vexRT(Ch1));
      move(RB, -vexRT(Ch1));
    case 3: //Rotation with motion
      float k = 0.25;
      move(LF, (int)(v(vexRT(Ch3)) + k * v(vexRT(Ch1))));
      move(LB, (int)(v(vexRT(Ch3)) + k * v(vexRT(Ch1))));
      move(RF, (int)(v(vexRT(Ch3)) - k * v(vexRT(Ch1))));
      move(RB, (int)(v(vexRT(Ch3)) - k * v(vexRT(Ch1))));
    default: //JUST IN CASE
      move(LF, v(vexRT(Ch3)) + v(vexRT(Ch4)));
      move(RB, v(vexRT(Ch3)) + v(vexRT(Ch4)));
      move(LB, v(vexRT(Ch3)) - v(vexRT(Ch4)));
      move(RF, v(vexRT(Ch3)) - v(vexRT(Ch4)));
  }

}
